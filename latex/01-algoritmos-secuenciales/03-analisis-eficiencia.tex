%% LyX 2.3.5.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[letterpaper,oneside,spanish]{book}
\PassOptionsToPackage{vlined,linesnumbered,ruled}{algorithm2e}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\usepackage{pifont}
\usepackage{algorithm2e}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\pdfpageheight\paperheight
\pdfpagewidth\paperwidth


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\theoremstyle{plain}
\newtheorem{thm}{\protect\theoremname}
\theoremstyle{remark}
\newtheorem{rem}{\protect\remarkname}
\theoremstyle{definition}
\newtheorem{defn}{\protect\definitionname}
\theoremstyle{plain}
\newtheorem{prop}{\protect\propositionname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{indentfirst}

\usepackage{titlesec}
\titleformat{\chapter}[display]{\bfseries\centering\larger}{\normalsize{\chaptertitlename\ \thechapter}}{0.5ex}{}[]
\titlespacing*{\chapter}{0pt}{-50pt}{20pt}
\titleformat{\section}[hang]{\bfseries\normalsize}{\thesection\ }{0pt}{}[]
\titleformat{\subsection}[runin]{\bfseries\normalsize}{\thesubsection\ }{0pt}{}[]
\titleformat{\paragraph}[runin]{\itshape\normalsize}{\theparagraph\ }{0pt}{}[]

\newtheoremstyle{myplain}{\topsep}{\topsep}{\itshape}{}{\scshape}{.}{.5em}{}
\newtheoremstyle{mydef}{\topsep}{\topsep}{\normalfont}{}{\scshape}{.}{.5em}{}
\theoremstyle{myplain}
\newtheorem{mythm}{Teorema}[]
\newtheorem{mylem}{Lema}[]
\newtheorem{myprop}{Proposición}[]
\theoremstyle{mydef}
\newtheorem{mydef}{Definición}[]
\newtheorem{myrmk}{Observación}[]
\newtheorem{myex}{Ejemplo}[]

\let\thm\mythm
\let\endthm\endmythm
\let\lem\mylem
\let\endlem\endmylem
\let\prop\myprop
\let\endprop\endmyprop
\let\defn\mydef
\let\enddefn\endmydef
\let\example\myex
\let\endexample\endmyex
\let\rem\myrmk
\let\endrem\endmyrmk

\usepackage{xpatch}
\newcommand{\proofnamefont}{\scshape}
\xpatchcmd{\proof}{\itshape}{\normalfont\proofnamefont}{}{}

\AtBeginDocument{
  \def\labelitemi{\Pisymbol{psy}{183}}
  \def\labelitemii{\Pisymbol{psy}{45}}
  \def\labelitemiii{\Pisymbol{psy}{215}}
}

\makeatother

\usepackage{babel}
\addto\shorthandsspanish{\spanishdeactivate{~<>.}}

\providecommand{\definitionname}{Definición}
\providecommand{\propositionname}{Proposición}
\providecommand{\remarkname}{Observación}
\providecommand{\theoremname}{Teorema}

\begin{document}

\chapter*{Análisis de la Eficiencia de un Algoritmo}

Después de demostrar que un algoritmo es correcto, el sig. paso es
caracterizar su tiempo de ejecución. El procedimiento que se sigue
para realizar esta tarea se demonima \emph{análisis de la eficiencia}
\emph{de un algoritmo }(o, simplemente, \emph{análisis de eficiencia}).
En este contexto, cuando se habla del ``tiempo de ejecución'' de
alguna operación o algoritmo, en realidad se está hablando de la cantidad
total de instrucciones que se ejecutan.

\section*{El modelo de cómputo RAM}

Un \emph{modelo de cómputo} es una representación simplificada de
alguna tecnología de cómputo particular que funge como una ``máquina
hipotética'' donde se puede simular la ejecución de un algoritmo
y, así, poder llevar a cabo su análisis. Para ello, el modelo debe
ser lo suficientemente simple para que facilite el análisis y, a la
vez, lo suficientemente cercano a la tecnología que representa para
que refleje lo más fielmente posible el comportamiento que tendría
el algoritmo de ser implementado en la tecnología representada. Existen
varios modelos de cómputo, pero el más comúnmente utilizado para analizar
algoritmos secuenciales es el \emph{modelo de cómputo RAM}. 

El modelo de cómputo RAM (random access machine) simula la arquitectura
de von Neumann y, como tal, consiste de una unidad de procesamiento
central (CPU o procesador) conectada a una unidad de memoria de acceso
aleatorio. En la arquitectura de von Neumann, las instrucciones y
los datos se almacenan en la misma unidad de memoria y comparten el
mismo medio de transmisión. Como consecuencia, el procesador no puede
ejecutar una instrucción al mismo tiempo que lee o escribe un dato
en la memoria. Así, el \emph{ciclo de máquina} del modelo RAM consiste
de tres pasos: primero, se lee un dato de la memoria, después, se
ejecuta alguna instrucción sobre ése dato y, finalmente, se escribe
el resultado en la memoria. Cada ciclo de máquina se ejecuta en tiempo
constante (i.e. independiente del valor o tamaño del dato de entrada). 

En términos prácticos, al simular la ejecución de un algoritmo en
el modelo RAM, se deben seguir las sig. suposiciones:
\begin{itemize}
\item Las instrucciones se pueden ejecutar únicamente de forma secuencial;
no se permite ejecutar instrucciones de forma concurrente. 
\item Todas las operaciones lógicas, aritméticas y de comparación se ejecutan
en tiempo constante, con la excepción del exponente, el factorial,
la raíz, el logaritmo, i.a.
\item Se cuenta con una cantidad infinita de memoria. 
\item Todas las operaciones de memoria (ya sea por puntero, índice o variable)
se ejecutan en tiempo constante; no se hace distinción entre si un
dato se encuentra en memoria caché, en la memoria RAM, en el disco
duro, etc. 
\item Invocar una rutina toma tiempo constante, pero el tiempo requerido
para ejecutar dicha rutina depende del tamaño de su entrada.
\end{itemize}

\section*{Entradas a considerar}

Las clases de entrada de un algoritmo pueden categorizarse en tres
casos diferentes, dependiendo de cómo influyen en el tiempo de ejecución
de dicho algoritmo:
\begin{itemize}
\item \emph{Mejor caso}: son todos los casos específicos que provocan que
el algoritmo ejecute la menor cantidad total de instrucciones posible. 
\item \emph{Peor caso}: son todos los casos específicos que provocan que
el algoritmo ejecute la mayor cantidad total de instrucciones posible. 
\item \emph{Caso promedio}: representa la cantidad promedio de instrucciones
que el algoritmo realiza para todos los posibles casos específicos. 
\end{itemize}
En la práctica, se suele estudiar únicamente el peor caso. Esto porque
el peor caso determina cuál es la máxima cantidad de tiempo que puede
llegar a tardar el algoritmo. Por otro lado, estudiar el caso promedio
es complicado debido a que no siempre es fácil ver cuáles clases de
entrada constituyen el caso promedio, puesto que no siempre se tiene
que todas las diferentes clases ocurren con la misma frecuencia. Además,
frecuentemente ocurre que el caso promedio es casi tan tardado como
el peor caso. Debido a esto, sólo en algunas ocasiones es de interés
estudiar el caso promedio, por ejemplo, cuando el caso promedio ocurre
con mayor frecuencia que los otros casos o cuando se está analizando
un algoritmo aleatorio. 

\section*{Procedimiento general}

El análisis de la eficiencia de un algoritmo consiste de multiplicar
el tiempo de ejecución de cada instrucción del algoritmo (suponiendo
que se ejecuta en el modelo RAM) por el número de veces que se ejecuta
(dada una entrada genérica de tamaño arbitrariamente grande y perteneciente
a alguna de las clases de entrada identificadas) y sumar los resultados
obtenidos. 

El producto final del análisis es una función $T:\mathbb{N}\to\mathbb{N}$
que determina el número total de instrucciones que el algoritmo ejecuta
en proporción al tamaño $n\in\mathbb{N}$ de la entrada, donde el
significado de ``tamaño'' depende del contexto del problema que
se está tratando. Aunque es posible encontrar esta función de forma
algebraica, es más fácil trabajar con la notación asintótica y expresar
dicha función por medio de su orden de crecimiento. Finalmente, se
puede suponer, sin pérdida de generalidad, que $T$ es una función
asintóticamente positiva. 

\section*{Relaciones de recurrencia}

Una relación de recurrencia (o, simplemente, \emph{recurrencia}) es
una función expresada en términos de sí misma pero con un valor reducido
para la variable independiente. Las recurrencias se presentan al analizar
la eficiencia de algoritmos de tipo \emph{divide y vencerás}. La \emph{forma
cerrada} de una recurrencia es una función equivalente a la recurrencia,
pero sin recursividad. Resolver una recurrencia implica encontrar
su forma cerrada.

En el contexto de los algoritmos divide y vencerás, las recurrencias
suelen tener la sig. forma general: 

\[
T(n)=\begin{cases}
B(n) & \text{para }n\leq b\\
\sum_{i=1}^{p}T(n_{i})+F(n) & \text{en caso contrario}
\end{cases}
\]
donde 
\begin{itemize}
\item $b\in\mathbb{N}$ es la condición de paro (boundary condition); esto
es, el tamaño de entrada requerido para llegar al caso base de la
recursividad, 
\item $B:\mathbb{N}\to\mathbb{N}$ es el tiempo de ejecución del caso base, 
\item $p\in\mathbb{N}$ es la cantidad de subproblemas en las que se dividió
la entrada, 
\item $n_{i}\in\mathbb{N}$, tal que $n_{i}<n$, es el tamaño de la entrada
para el subproblema $i$, 
\item $F:\mathbb{N}\to\mathbb{N}$ es el tiempo de ejecución para dividir
la entrada en y/o combinar las soluciones de los $p$ subproblemas 
\end{itemize}
La función $B$ suele omitirse cuando es constante. A continuación
se presentan tres técnicas diferentes para resolver recurrencias.

\subsection*{Teorema maestro}

El teorema maestro (también conocido como el \emph{método maestro})
consiste simplemente en aplicar el sig. teorema.
\begin{thm}[Teorema maestro]
Sean $a,n\in\mathbb{N}$ y $b\in\mathbb{R}$, donde $a$ y $b$ son
constantes y $b>1$. Sea $f:\mathbb{N}\to\mathbb{N}$ una función
asintóticamente positiva y denótese $c=\log_{b}a$. Si $T:\mathbb{N}\to\mathbb{N}$
es una recurrencia de la forma $T(n)=aT(n/b)+f(n)$, entonces su forma
cerrada se puede calcular de alguna de las sig. maneras:
\begin{enumerate}
\item Si $f=O(n^{c-\varepsilon})$ para alguna constante real $\varepsilon>0$,
entonces $T=\Theta(n^{c})$.
\item Si $f=\Theta(n^{c})$, entonces $T=\Theta(n^{c}\lg n)$.
\item Si $f=\Omega(n^{c+\varepsilon})$ y si, además, $af(n/b)\leq kf(n)$
para alguna constante real $k<1$ y todo valor de $n$ pasado algún
umbral, entonces $T=\Theta(f)$.
\end{enumerate}
\end{thm}
\begin{rem}
Para este teorema, el término $n/b$ también se puede interpretar
como $\lceil n/b\rceil$ o $\lfloor n/b\rfloor$.
\end{rem}
En el contexto de este teorema, ``en un factor polinomial'' se refiere
a que $n^{c}/f(n)$ resulta en un polinomio de grado $\varepsilon$.
La principal desventaja del teorema maestro es que no puede aplicarse
a cualquier tipo de recurrencia.

\subsection*{Método del árbol recursivo}

El método del árbol recursivo es un método gráfico e informal que
consiste de construir un árbol donde cada subárbol representa el tiempo
requerido para resolver un subproblema de una recurrencia. Al sumar
el tiempo total de cada nivel del árbol se obtiene la forma cerrada
de la recurrencia. 

Antes de estudiar el método en sí, es importante recordar algunos
conceptos sobre árboles.
\begin{defn}[Árbol $k$-ario]
Sea $k\in\mathbb{N}_{0}$. Un árbol $k$-ario es un árbol enraizado
donde cada nodo tiene a lo más $k$ hijos. 
\end{defn}
%
\begin{defn}[Árbol completo]
Se dice que un árbol $k$-ario es completo si todos los nodos internos
tienen exactamente $k$ hijos y todas las hojas se encuentran en el
último nivel. 
\end{defn}
%
\begin{defn}[Altura de un árbol]
Sean $h,n\in\mathbb{N}$. La altura de un árbol $k$-ario, denotada
por $h$, es la cantidad de niveles que tiene. Se calcula como $h=\lfloor\log_{k}n\rfloor+1$,
donde $n$ es el número total de nodos en el árbol.
\end{defn}
%
\begin{prop}
Sea $i\in\mathbb{N}_{0}$. Suponiendo que la raíz de un árbol $k$-ario
completo se encuentra en el nivel 0, la cantidad de nodos en el nivel
$i$, denotado por $n_{i}$, se calcula como $n_{i}=k^{i}$.
\end{prop}
El método del árbol recursivo consiste de los sig. pasos:
\begin{enumerate}
\item Desglozar la recurrencia en un árbol de tal forma que la raíz representa
el tiempo requerido para combinar y/o dividir el problema original,
cada nodo interno representa el tiempo requerido para combinar y/o
dividir un subproblema y cada hoja representa el tiempo requerido
para el caso base. 
\item Calcular la altura del árbol.
\item Calcular la cantidad de hojas.
\item Calcular el tiempo de ejecución de cada nivel. 
\item Sumar el tiempo de ejecución de todos los niveles para obtener la
forma cerrada.
\end{enumerate}

\subsection*{Método de sustitución}

El método de sustitución es un método formal que consiste en resolver
una recurrencia por inducción matemática. Específicamente, este método
consiste de los sig. pasos:
\begin{enumerate}
\item Proponer una cota tentativa para la forma cerrada de la recurrencia.
\item Utilizar inducción matemática para demostrar que la cota propuesta
es correcta y para encontrar las constantes de dicha cota.
\end{enumerate}
Este método se puede utilizar para calcular tanto una cota superior
como una inferior. A continuación se presentan algunas consideraciones
y consejos que se deben tener en cuenta al trabajar con este método. 

\paragraph*{Proponiendo una buena solución tentativa}

Se puede utilizar el método del árbol recursivo para obtener una solución
tentativa para la recurrencia y después utilizar el método de sustitución
para demostrar que dicha solución es correcta o para ajustar la cota.
Si la recurrencia tiene una forma similar a alguna otra que se haya
resuelto anteriormente, se puede proponer la solución de la recurrencia
anterior como la solución tentativa de la recurrencia actual. Finalmente,
si no se está completamente seguro de cuál es la solución, se pueden
proponer dos cotas holgadas, una inferior y una superior, y ajustarlas
gradualmente hasta que converjan en la solución correcta. 

\paragraph*{Cuidado con la notación asintótica}

Aunque la solución de una recurrencia se expresa en notación asintótica,
el objetivo del método de sustitución es demostrar que dicha cota
se cumple de forma exacta. Por ejemplo, suponiendo que se desea demostrar
que $T=O(n^{2})$, lo que se debe hacer es calcular el valor de la
constante $c$ que satisfaga la expresión $T(n)\leq cn^{2}$ para
valores suficientemente grandes de $n$. Un error común es aplicar
la notación asintótica prematuramente durante la inducción para eliminar
constantes o términos problemáticos.

\paragraph*{Diferencias con la inducción matemática}

A diferencia de la notación matemática, en el método de sustitución
el caso base se realiza hasta el último. Además, la hipótesis inductiva
consiste de suponer que la cota propuesta se cumple para $T(n_{i})$,
para toda $n_{i}<n$. Así, el paso inductivo consiste en sustituir
$T(n_{i})$, en la recurrencia origial, con la forma exacta de la
cota propuesta, lo que da origen al nombre del método.

\paragraph{Ajustando la hipótesis inductiva}

En algunas ocasiones, puede ocurrir que la solución propuesta es,
de hecho, la solución correcta, pero la inducción no converge exactamente
a dicho resultado. En estos casos, uno podría estar tentado a proponer
una cota más holgada. En lugar de eso, se puede simplemente proponer
una nueva hipótesis inductiva, que sea igual a la original pero restándole
los términos de menor grado. 

\subsection*{Uso creativo del álgebra}

En ocasiones, en lugar de utilizar cualquiera de los métodos mencionados
anteriormente, se puede aplicar un poco de álgebra para transformar
una recurrencia en alguna otra cuya solución ya se conozca.

\section*{Notas bibliográficas}

En las págs. 112 y 113 del libro de Cormen et al. (2009) se proporcionan
referencias a varios otros métodos que existen para resolver diferentes
tipos de recurrencias. Uno de ellos es el método de Akra-Bazzi, el
cual es una generalización del teorema maestro que admite variables
contínuas y permite resolver recurrencias donde los subproblemas varían
substancialmente de tamaño. Además, Drmota y Szpankowski (2013) proponen
una extensión del método de Akra-Bazzi para trabajar con variables
discretas en lugar de contínuas. 
\begin{itemize}
\item Cormen T.H., Leiserson C.E., Rivest R.L. \& Stein C., ``Introduction
to Algorithms'', 3ra ed. (2009), MIT Press. Págs. 23-29, 83-106 y
112-113.
\item Skiena S.S., ``The Algorithm Design Manual'', 2da ed. (2012), Springer.
Págs. 31-34.
\item Drmota M. \& Szpankowski W., ``A Master Theorem for Discrete Divide
and Conquer Recurrences'', Journal of the ACM (2013), Art. No. 16.
\end{itemize}

\end{document}
