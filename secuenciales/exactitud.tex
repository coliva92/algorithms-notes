\chapter{Análisis de la Exactitud de un Algoritmo}

El primer paso al analizar un algoritmo es determinar si éste es correcto
o incorrecto. El procedimiento que se sigue para llevar a cabo esta
tarea se denomina \emph{análisis de la exactitud de un algoritmo}.

\section{Contraejemplo}

Para demostrar que un algoritmo es incorrecto, basta con producir
un \emph{contraejemplo}; i.e. un caso específico para el cual el algoritmo
no termina su ejecución o no produce un resultado que cumple las características
de salida del problema. 

Para producir un contraejemplo, se deben explorar todas las clases
de entrada posibles. Se recomienda comenzar por aquellas que representen
las situaciones más complicadas o inconvenientes para el algoritmo. Por ejemplo, si
se trata de un algoritmo voraz, se puede proponer un caso donde todos
los valores están empatados. Para otros tipos de algoritmos, se pueden
proponer casos que contengan mezclados valores de frontera de extremos
opuestos. Por ejemplo, casos con valores muy grandes y muy pequeños,
muy cerca y muy lejos, muchos y muy pocos, etc.

El contraejemplo debe ser lo más simple y pequeño posible; idealmente,
la razón de por qué el algoritmo es incorrecto debe ser inmediatamente
clara. Así, una vez encontrado un contraejemplo, se recomienda simplificarlo
tanto como sea posible. Además, el contraejemplo debe presentarse
junto con el resultado incorrecto que produjo el algoritmo y el resultado
correcto que debió producir.

Es importante destacar que, si no se logra encontrar un contraejemplo
para un algoritmo determinado, esto no implica que dicho algoritmo
es correcto; aún es necesario demostrar su exactitud.

\section{La invariante de lazo}

Una \emph{invariante de lazo} (loop invariant; abreviado como IL) es una proposición
lógica que se cumple inmediatamente antes e inmediatamente después
de cada iteración de un bucle o algoritmo iterativo determinado. La
IL siempre se define en función del número de iteraciones.

Para producir una IL, se recomienda primero hacer
una ``prueba de escritorio'' del bucle; i.e. ejecutar cada paso
del algoritmo en una hoja de papél con uno o varios casos específicos
de prueba. Esto permite identificar patrones en el comportamiento
de dicho bucle que podrían aprovecharse para definir la IL. 

Demostrar que una IL se cumple para cualquier iteración
es un procedimiento análogo a una demostración por inducción y consiste
de los sig. pasos: 

\begin{enumerate}
    \item \emph{Inicialización}: se considera cuál es el estado que se tiene
    antes de ejecutar la primera iteración y se demuestra que la IL se cumple bajo estas condiciones.
    \item \emph{Mantenimiento}: se supone que la IL se cumple
    antes de comenzar alguna iteración genérica $i$ y se determina el
    estado que se obtiene como consecuencia de ello. Después, se ejecuta
    la iteración $i$ y se demuestra que la IL se cumple antes
    de comenzar la iteración $i+1$.
    \item \emph{Finalización}: se determina cuál es el estado al salir del bucle
    y se utiliza la IL para demostrar que el algoritmo
    es correcto o para caracterizar alguna propiedad particular del algoritmo. 
\end{enumerate}

\section{Cómo diseñar algoritmos correctos}

El diseño de un algoritmo es un proceso iterativo; rara vez se puede
diseñar un algoritmo correcto en el primer intento. A continuación
se presentan algunos consejos para diseñar algoritmos correctos. 

\subsection{Definir el problema correctamente}

Si el problema no está bien definido, será muy difícil o incluso imposible
diseñar un algoritmo que lo resuelva. 

Las características de salida
deben ser claras y no deben consistir de objetivos compuestos. Por
ejemplo, decir ``encontrar la mejor ruta entre dos puntos en un mapa'',
es un problema mal definido, pues no queda claro a qué se refiere
exactamente con ``la mejor ruta''. Otro ejemplo, decir ``encontrar
la ruta más corta entre dos puntos en un mapa que además requiera
menos del doble de los giros a la izquierda de los que son mínimamente
necesarios'', es un problema bien definido pero muy difícil de resolver
pues la salida consiste de cumplir varios objetivos intermedios. 

En cuanto a las características de entrada, típicamente entre más
restrictivas sean, menor es la dificultad para resolver el problema.
Por ende, se recomienda comenzar por diseñar un algoritmo correcto
que admita entradas de características muy particulares y después
extenderlo a entradas más generales. Por ejemplo, en lugar de trabajar
con grafos generales, se puede trabajar primero con árboles.

\subsection{Analizar la complejidad computacional del problema}

Se recomienda analizar la complejidad computacional del problema al
mismo tiempo que se diseña un algoritmo para resolverlo. De esta forma,
cualquier descubrimiento o avance que se obtenga por un lado podría
aprovecharse después para avanzar en el otro. Además, al final se
obtendría uno de dos posibles resultados: ya sea se llega a la construcción
de un algoritmo correcto o se caracteriza la complejidad computacional
del problema.

\subsection{Elegir un modelo adecuado}

Las entidades con las que interactúa un problema en la vida real suelen
representarse por medio de alguna de varias estructuras abstractas
ya conocidas (e.g. cadenas, grafos, conjuntos, etc.). Sin embargo,
las especificaciones del problema no siempre se ajustan perfectamente
a las características de la estructura elegida. En estos casos, se
recomienda ignorar temporalmente aquellos detalles que no encajen
y decidir más adelante, después de trabajar un tiempo con esa estructura,
si dichos detalles son realmente esenciales o no para resolver el
problema. 

\section*{Notas bibliográficas}

\begin{itemize}
    \item \textcite{cormen_introduction_2009}, págs. 18-20. 
    \item \textcite{skiena_algorithm_2011}, págs. 11-16.
\end{itemize}
