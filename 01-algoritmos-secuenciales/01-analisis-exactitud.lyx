#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\usepackage{indentfirst}

\usepackage{titlesec}
\titleformat{\chapter}[display]{\bfseries\centering\larger}{\normalsize{\chaptertitlename\ \thechapter}}{0.5ex}{}[]
\titlespacing*{\chapter}{0pt}{-50pt}{20pt}
\titleformat{\section}[hang]{\bfseries\normalsize}{\thesection\ }{0pt}{}[]
\titleformat{\subsection}[runin]{\bfseries\normalsize}{\thesubsection\ }{0pt}{}[]
\titleformat{\paragraph}[runin]{\itshape\normalsize}{\theparagraph\ }{0pt}{}[]

\newtheoremstyle{myplain}{\topsep}{\topsep}{\itshape}{}{\scshape}{.}{.5em}{}
\newtheoremstyle{mydef}{\topsep}{\topsep}{\normalfont}{}{\scshape}{.}{.5em}{}
\theoremstyle{myplain}
\newtheorem{mythm}{Teorema}[]
\newtheorem{mylem}{Lema}[]
\newtheorem{myprop}{Proposición}[]
\theoremstyle{mydef}
\newtheorem{mydef}{Definición}[]
\newtheorem{myrmk}{Observación}[]
\newtheorem{myex}{Ejemplo}[]

\let\thm\mythm
\let\endthm\endmythm
\let\lem\mylem
\let\endlem\endmylem
\let\prop\myprop
\let\endprop\endmyprop
\let\defn\mydef
\let\enddefn\endmydef
\let\example\myex
\let\endexample\endmyex
\let\rem\myrmk
\let\endrem\endmyrmk

\usepackage{xpatch}
\newcommand{\proofnamefont}{\scshape}
\xpatchcmd{\proof}{\itshape}{\normalfont\proofnamefont}{}{}
\end_preamble
\use_default_options true
\begin_modules
algorithm2e
theorems-ams-bytype
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Format 66
PackageOptions algorithm2e "vlined,linesnumbered,ruled"
\end_local_layout
\language spanish-mexico
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tb
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.57in
\topmargin 1.2in
\rightmargin 1.2in
\bottommargin 1.2in
\secnumdepth 3
\tocdepth 0
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Análisis de la Exactitud de un Algoritmo
\end_layout

\begin_layout Standard
El primer paso al analizar un algoritmo es determinar si éste es correcto
 o incorrecto.
 El procedimiento que se sigue para llevar a cabo esta tarea se denomina
 
\emph on
análisis de la exactitud
\emph default
 
\emph on
de un algoritmo
\emph default
 (o, simplemente, 
\emph on
análisis de exactitud
\emph default
).
\end_layout

\begin_layout Section
Contraejemplo
\end_layout

\begin_layout Standard
Para demostrar que un algoritmo es incorrecto, basta con producir un 
\emph on
contraejemplo
\emph default
; esto es, un caso específico para el cual el algoritmo no produce un resultado
 que satisfaga los requerimientos de salida del problema o no termina su
 ejecución.
 Para producir un contraejemplo, es necesario considerar todas las posibles
 clases de entrada.
 Se recomienda probar primero con casos específicos extremos o con valores
 de frontera.
 El contraejemplo propuesto debe ser lo más simple y pequeño posible y,
 para complementarlo, se debe determinar el resultado incorrecto que el
 algoritmo produce para dicho contraejemplo y compararlo con el resultado
 correcto que debió haber producido.
 
\end_layout

\begin_layout Standard
En caso de no haberse encontrado un contraejemplo para un algoritmo determinado,
 esto no implica que dicho algoritmo es correcto; aún es necesario presentar
 una demostración convincente de su exactitud.
\end_layout

\begin_layout Section
La invariante de lazo
\end_layout

\begin_layout Standard
Una invariante de lazo es una proposición lógica que se cumple inmediatamente
 antes e inmediatamente después de cada iteración de un bucle determinado.
 Para producir una invariante de lazo, se recomienda primero hacer una 
\begin_inset Quotes fls
\end_inset

prueba de escritorio
\begin_inset Quotes frs
\end_inset

 del bucle.
 Esto ayuda a encontrar patrones en el comportamiento de dicho bucle que
 podrían utilizarse para definir una invariante de lazo.
 La invariante de lazo siempre se define en función del número de iteraciones
 ejecutadas hasta el momento.
 
\end_layout

\begin_layout Standard
Demostrar que una invariante de lazo es verdadera para cualquier iteración
 es un procedimiento análogo a una demostración por inducción y consiste
 de las sig.
 etapas: 
\end_layout

\begin_layout Enumerate

\emph on
Inicialización
\emph default
: se considera cuál es el estado del algoritmo que se tiene antes de comenzar
 a ejecutar la primera iteración
\emph on
 
\emph default
del bucle y se procede a demostrar que la invariante de lazo se cumple bajo
 estas condiciones.
\end_layout

\begin_layout Enumerate

\emph on
Mantenimiento
\emph default
: se hace la suposición de que la invariante de lazo se cumple antes de
 comenzar alguna iteración genérica 
\begin_inset Formula $i$
\end_inset

 y se determina el estado del algoritmo que se obtiene como consecuencia
 de ello.
 Después, partiendo de dicho estado, se ejecuta una iteración del bucle
 y, de nuevo, se determina el estado del algoritmo que se obtuvo como resultado.
 Finalmente, partiendo de dicho estado, se procede a demostrar que la invariante
 de lazo se cumple antes de comenzar la iteración 
\begin_inset Formula $i+1$
\end_inset

.
\end_layout

\begin_layout Enumerate

\emph on
Finalización
\emph default
: se determina cuál es el estado del algoritmo cuando el bucle termina su
 ejecución y, partiendo de dicho estado, se procede a utilizar la invariante
 de lazo para demostrar que el algoritmo es correcto o para demostrar que
 se cumple alguna propiedad particular del algoritmo.
 
\end_layout

\begin_layout Section
Cómo diseñar algoritmos correctos
\end_layout

\begin_layout Standard
Rara vez es posible producir un nuevo algoritmo correcto en el primer intento;
 normalmente, el diseño de un algoritmo es un proceso iterativo.
 A continuación se presentan algunos consejos que pueden facilitar la tarea
 de diseñar algoritmos correctos.
 
\end_layout

\begin_layout Subsection
Definir bien el problema
\end_layout

\begin_layout Standard
Si el problema no está bien definido, el algoritmo será incorrecto sin importar
 lo que haga.
 Los requerimientos de salida deben ser concisos y explícitos y no deben
 consistir de objetivos compuestos.
 Por otro lado, entre más restrictivos sean los requerimientos de entrada,
 menor suele ser la dificultad para resolver el problema.
 
\end_layout

\begin_layout Subsection
Estudiar la complejidad computacional del problema
\end_layout

\begin_layout Standard
Se recomienda estudiar la complejidad computacional del problema al mismo
 tiempo que se diseña un algoritmo para resolverlo.
 Esto porque, cualquier descubrimiento o avance que se obtenga en uno podría
 aprovecharse después para avanzar el otro.
 Además, al final se obtendría uno de dos posibles resultados: ya sea se
 llega a la construcción de un algoritmo correcto o se demuestra la complejidad
 del problema.
\end_layout

\begin_layout Subsection
Elegir un modelo adecuado
\end_layout

\begin_layout Standard
Las entidades con las que interactúa un problema en la vida real suelen
 representarse por medio de alguna de varias estructuras abstractas ya conocidas
 (e.g.
 cadenas, grafos, conjuntos, etc.).
 Sin embargo, las especificaciones del problema no siempre se ajustarán
 perfectamente a las características de la estructura elegida.
 En estos casos, se recomienda ignorar temporalmente aquellos detalles que
 no encajen y decidir más adelante, después de trabajar un tiempo con esa
 estructura, si dichos detalles son realmente esenciales o no para resolver
 el problema.
 
\end_layout

\begin_layout Section*
Notas bibliográficas
\end_layout

\begin_layout Itemize
Cormen T.H., Leiserson C.E., Rivest R.L.
 & Stein C., 
\begin_inset Quotes fls
\end_inset

Introduction to Algorithms
\begin_inset Quotes frs
\end_inset

, 3ra ed.
 (2009), MIT Press.
 Págs.
 18-20.
 
\end_layout

\begin_layout Itemize
Skiena S.S., 
\begin_inset Quotes fls
\end_inset

The Algorithm Design Manual
\begin_inset Quotes frs
\end_inset

, 2da ed.
 (2012), Springer.
 Págs.
 11-16.
\end_layout

\end_body
\end_document
