#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\usepackage{titlesec}
\titleformat{\chapter}[display]{\bfseries\centering\large}{\normalsize{\chaptertitlename\ \thechapter}}{0.5ex}{}[]
\titlespacing*{\chapter}{0pt}{-50pt}{20pt}
\titleformat{\section}[hang]{\bfseries\large}{\thesection\ }{0pt}{}[]
\titleformat{\subsection}[hang]{\bfseries\normalsize}{\thesubsection\ }{0pt}{}[]
\titleformat{\paragraph}[runin]{\itshape\normalsize}{\theparagraph\ }{0pt}{}[]

\usepackage{enumitem}
\setlist{nolistsep}

\SetKwInOut{In}{Entrada}
\SetKwInOut{Out}{Salida}
\SetKw{Throw}{throw}
\SetKw{Error}{error}
\SetKw{And}{and}
\SetKw{Or}{or}
\SetKw{Not}{not}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Nil}{nil}
\SetCommentSty{textit}
\SetKwComment{Comment}{$\triangleright$ }{}
\SetFuncSty{textsc}
\DontPrintSemicolon
\end_preamble
\use_default_options true
\begin_modules
algorithm2e
theorems-ams-chap-bytype
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Format 66
PackageOptions algorithm2e "algochapter,vlined,linesnumbered,ruled"
\end_local_layout
\language spanish-mexico
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tb
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize letterpaper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.57in
\topmargin 1.2in
\rightmargin 1.2in
\bottommargin 1.2in
\secnumdepth 2
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Análisis de la Exactitud de un Algoritmo
\end_layout

\begin_layout Standard
El primer paso al analizar un algoritmo es determinar si este es correcto
 o incorrecto.
 El procedimiento que se sigue para llevar a cabo esta tarea se denomina
 
\emph on
análisis de la exactitud
\emph default
 
\emph on
de un algoritmo
\emph default
.
\end_layout

\begin_layout Section
Contraejemplo
\end_layout

\begin_layout Standard
Para demostrar que un algoritmo es incorrecto, basta con producir un 
\emph on
contraejemplo
\emph default
; i.e.
 un caso específico para el cual el algoritmo no termina su ejecución o
 no produce un resultado que cumpla las características de salida del problema.
 
\end_layout

\begin_layout Standard
Para producir un contraejemplo, se deben explorar todas las clases de entrada
 posibles.
 Se recomienda comenzar por aquellas que representen las situaciones más
 complicadas para el algoritmo.
 Por ejemplo, si se trata de un algoritmo voraz, se puede proponer un caso
 donde todos los valores estén empatados.
 Para otros tipos de algoritmos, se pueden proponer casos que contengan
 mezclados valores de frontera de extremos opuestos.
 Por ejemplo, casos con valores muy grandes y muy pequeños, muy cerca y
 muy lejos, muchos y muy pocos, etc.
\end_layout

\begin_layout Standard
El contraejemplo debe ser lo más simple y pequeño posible; idealmente, la
 razón de por qué el algoritmo es incorrecto debe ser inmediatamente visible.
 Así, una vez encontrado un contraejemplo, se recomienda simplificarlo tanto
 como sea posible.
 Además, el contraejemplo debe presentarse junto con el resultado incorrecto
 que produjo el algoritmo y el resultado correcto que debió producir.
\end_layout

\begin_layout Standard
Es importante destacar que, si no se logra encontrar un contraejemplo para
 un algoritmo determinado, esto no implica que dicho algoritmo es correcto;
 aún es necesario demostrar su exactitud.
\end_layout

\begin_layout Section
La invariante de lazo
\end_layout

\begin_layout Standard
Una 
\emph on
invariante de lazo
\emph default
 (loop invariant) es una proposición lógica que se cumple inmediatamente
 antes e inmediatamente después de cada iteración de un bucle o algoritmo
 iterativo determinado.
 La invariante de lazo siempre se define en función del número de iteraciones.
\end_layout

\begin_layout Standard
Para producir una invariante de lazo, se recomienda primero hacer una 
\begin_inset Quotes fls
\end_inset

prueba de escritorio
\begin_inset Quotes frs
\end_inset

 del bucle.
 Esto es, ejecutar cada paso del algoritmo en una hoja de papél con uno
 o varios casos específicos de prueba.
 Esto permite identificar patrones en el comportamiento de dicho bucle que
 podrían aprovecharse para definir una invariante de lazo.
 
\end_layout

\begin_layout Standard
Demostrar que una invariante de lazo se cumple para cualquier iteración
 es un procedimiento análogo a una demostración por inducción y consiste
 de los sig.
 pasos: 
\end_layout

\begin_layout Enumerate

\emph on
Inicialización
\emph default
: se considera cuál es el estado que se tiene antes de ejecutar la primera
 iteración y se demuestra que la invariante de lazo se cumple bajo estas
 condiciones.
\end_layout

\begin_layout Enumerate

\emph on
Mantenimiento
\emph default
: se supone que la invariante de lazo se cumple antes de comenzar alguna
 iteración genérica 
\begin_inset Formula $i$
\end_inset

 y se determina el estado que se obtiene como consecuencia de ello.
 Después, se ejecuta una iteración y se demuestra que la invariante de lazo
 se cumple antes de comenzar la iteración 
\begin_inset Formula $i+1$
\end_inset

.
\end_layout

\begin_layout Enumerate

\emph on
Finalización
\emph default
: se determina cuál es el estado al salir del bucle y se utiliza la invariante
 de lazo para demostrar que el algoritmo es correcto o para caracterizar
 alguna propiedad particular del algoritmo.
 
\end_layout

\begin_layout Section
Cómo diseñar algoritmos correctos
\end_layout

\begin_layout Standard
El diseño de un algoritmo es un proceso iterativo; rara vez se puede diseñar
 un algoritmo correcto en el primer intento.
 A continuación se presentan algunos consejos para diseñar algoritmos correctos.
 
\end_layout

\begin_layout Subsection
Definir el problema correctamente
\end_layout

\begin_layout Standard
Si el problema no está bien definido, será muy difícil o incluso imposible
 diseñar un algoritmo que lo resuelva.
 Las características de salida deben ser claras y no deben consistir de
 objetivos compuestos.
 Por ejemplo, decir 
\begin_inset Quotes fls
\end_inset

encontrar la mejor ruta entre dos puntos en un mapa
\begin_inset Quotes frs
\end_inset

, es un problema mal definido, pues no queda claro a qué se refiere exactamente
 con 
\begin_inset Quotes fls
\end_inset

la mejor ruta
\begin_inset Quotes frs
\end_inset

.
 Otro ejemplo, decir 
\begin_inset Quotes fls
\end_inset

encontrar la ruta más corta entre dos puntos en un mapa que además requiera
 menos del doble de los giros a la izquierda de los que son mínimamente
 necesarios
\begin_inset Quotes frs
\end_inset

, es un problema bien definido pero muy difícil de resolver pues la salida
 consiste de varios objetivos intermedios.
 
\end_layout

\begin_layout Standard
En cuanto a las características de entrada, típicamente entre más restrictivas
 sean, menor es la dificultad para resolver el problema.
 Por ende, se recomienda comenzar por diseñar un algoritmo correcto que
 admita entradas de características muy particulares y después extenderlo
 a entradas más generales.
 Por ejemplo, en lugar de trabajar con grafos generales, se puede comenzar
 por trabajar primero con árboles.
\end_layout

\begin_layout Subsection
Analizar la complejidad computacional del problema
\end_layout

\begin_layout Standard
Se recomienda analizar la complejidad computacional del problema al mismo
 tiempo que se diseña un algoritmo para resolverlo.
 De esta forma, cualquier descubrimiento o avance que se obtenga por un
 lado podría aprovecharse después para avanzar en el otro.
 Además, al final se obtendría uno de dos posibles resultados: ya sea se
 llega a la construcción de un algoritmo correcto o se caracteriza la complejida
d computacional del problema.
\end_layout

\begin_layout Subsection
Elegir un modelo adecuado
\end_layout

\begin_layout Standard
Las entidades con las que interactúa un problema en la vida real suelen
 representarse por medio de alguna de varias estructuras abstractas ya conocidas
 (e.g.
 cadenas, grafos, conjuntos, etc.).
 Sin embargo, las especificaciones del problema no siempre se ajustan perfectame
nte a las características de la estructura elegida.
 En estos casos, se recomienda ignorar temporalmente aquellos detalles que
 no encajen y decidir más adelante, después de trabajar un tiempo con esa
 estructura, si dichos detalles son realmente esenciales o no para resolver
 el problema.
 
\end_layout

\begin_layout Section*
Notas bibliográficas
\end_layout

\begin_layout Itemize
Cormen T.H., Leiserson C.E., Rivest R.L.
 & Stein C., 
\begin_inset Quotes fls
\end_inset

Introduction to Algorithms
\begin_inset Quotes frs
\end_inset

, 3ra ed.
 (2009), MIT Press.
 Págs.
 18-20.
 
\end_layout

\begin_layout Itemize
Skiena S.S., 
\begin_inset Quotes fls
\end_inset

The Algorithm Design Manual
\begin_inset Quotes frs
\end_inset

, 2da ed.
 (2012), Springer.
 Págs.
 11-16.
\end_layout

\end_body
\end_document
