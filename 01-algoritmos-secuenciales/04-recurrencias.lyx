#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\usepackage{titlesec}
\titleformat{\chapter}[display]{\bfseries\centering\large}{\normalsize{\chaptertitlename\ \thechapter}}{0.5ex}{}[]
\titlespacing*{\chapter}{0pt}{-50pt}{20pt}
\titleformat{\section}[hang]{\bfseries\large}{\thesection\ }{0pt}{}[]
\titleformat{\subsection}[hang]{\bfseries\normalsize}{\thesubsection\ }{0pt}{}[]
\titleformat{\paragraph}[runin]{\itshape\normalsize}{\theparagraph\ }{0pt}{}[]

\usepackage{enumitem}
\setlist{nolistsep}

\SetKwInOut{In}{Entrada}
\SetKwInOut{Out}{Salida}
\SetKw{Throw}{throw}
\SetKw{Error}{error}
\SetKw{And}{and}
\SetKw{Or}{or}
\SetKw{Not}{not}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Nil}{nil}
\SetCommentSty{textit}
\SetKwComment{Comment}{$\triangleright$ }{}
\SetFuncSty{textsc}
\DontPrintSemicolon
\end_preamble
\use_default_options true
\begin_modules
algorithm2e
theorems-ams-chap-bytype
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Format 66
PackageOptions algorithm2e "algochapter,vlined,linesnumbered,ruled"
\end_local_layout
\language spanish-mexico
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tb
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.57in
\topmargin 1.2in
\rightmargin 1.2in
\bottommargin 1.2in
\secnumdepth 2
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Relaciones de Recurrencia
\end_layout

\begin_layout Standard
Una 
\emph on
relación de recurrencia
\emph default
 (o, simplemente, 
\emph on
recurrencia
\emph default
) es una función expresada en términos de sí misma, pero con una entrada
 menor.
 Las recurrencias se presentan al analizar la eficiencia de algoritmos de
 tipo 
\emph on
divide y vencerás
\emph default
.
 La 
\emph on
forma cerrada
\emph default
 de una recurrencia es una función equivalente, pero expresada sin recursividad.
 Resolver una recurrencia implica encontrar su forma cerrada.
\end_layout

\begin_layout Standard
En el contexto de los algoritmos divide y vencerás, las recurrencias suelen
 tener la sig.
 forma general: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=\begin{cases}
\sum_{i=1}^{p}T(n_{i})+f(n) & \text{para }n>b\\
g(n) & \text{en caso contrario}
\end{cases}
\]

\end_inset

donde 
\end_layout

\begin_layout Itemize
\begin_inset Formula $b\in\mathbb{N}$
\end_inset

 es la condición de paro (boundary condition); esto es, el valor de 
\begin_inset Formula $n$
\end_inset

 requerido para entrar al caso base, 
\end_layout

\begin_layout Itemize
\begin_inset Formula $g:\mathbb{N}\to\mathbb{N}$
\end_inset

 es el tiempo de ejecución del caso base, 
\end_layout

\begin_layout Itemize
\begin_inset Formula $p\in\mathbb{N}$
\end_inset

 es la cantidad de subproblemas en las que se dividió la entrada, 
\end_layout

\begin_layout Itemize
\begin_inset Formula $n_{i}\in\mathbb{N}$
\end_inset

, tal que 
\begin_inset Formula $n_{i}<n$
\end_inset

, es el tamaño de la entrada para el subproblema 
\begin_inset Formula $i$
\end_inset

, 
\end_layout

\begin_layout Itemize
\begin_inset Formula $f:\mathbb{N}\to\mathbb{N}$
\end_inset

 es el tiempo de ejecución para dividir la entrada en y/o combinar las solucione
s de los 
\begin_inset Formula $p$
\end_inset

 subproblemas 
\end_layout

\begin_layout Standard
La función 
\begin_inset Formula $g$
\end_inset

 suele omitirse cuando es constante.
 
\end_layout

\begin_layout Standard
A continuación se presentan tres métodos diferentes para resolver recurrencias.
 Para ver ejemplos de estos métodos, se recomienda consultar el libro de
 Cormen et al.
 (2009).
\end_layout

\begin_layout Section
El método maestro
\end_layout

\begin_layout Standard
El método maestro consiste simplemente en aplicar el sig.
 teorema.
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Teorema maestro
\end_layout

\end_inset

Sean 
\begin_inset Formula $a,n\in\mathbb{N}$
\end_inset

 y 
\begin_inset Formula $b\in\mathbb{R}$
\end_inset

, donde 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

 son constantes y 
\begin_inset Formula $b>1$
\end_inset

.
 Sea 
\begin_inset Formula $f:\mathbb{N}\to\mathbb{N}$
\end_inset

 una función asintóticamente positiva y sea 
\begin_inset Formula $c=\log_{b}a$
\end_inset

.
 Si 
\begin_inset Formula $T:\mathbb{N}\to\mathbb{N}$
\end_inset

 es una recurrencia de la forma 
\begin_inset Formula $T(n)=aT(n/b)+f(n)$
\end_inset

, entonces se puede resolver de alguna de las sig.
 maneras:
\end_layout

\begin_deeper
\begin_layout Enumerate
Si 
\begin_inset Formula $f=O(n^{c-\varepsilon})$
\end_inset

 para alguna constante real 
\begin_inset Formula $\varepsilon>0$
\end_inset

, entonces 
\begin_inset Formula $T=\Theta(n^{c})$
\end_inset

.
\end_layout

\begin_layout Enumerate
Si 
\begin_inset Formula $f=\Theta(n^{c})$
\end_inset

, entonces 
\begin_inset Formula $T=\Theta(n^{c}\log n)$
\end_inset

.
\end_layout

\begin_layout Enumerate
Si 
\begin_inset Formula $f=\Omega(n^{c+\varepsilon})$
\end_inset

 y si, además, 
\begin_inset Formula $af(n/b)\leq kf(n)$
\end_inset

 para alguna constante real 
\begin_inset Formula $k<1$
\end_inset

 y todo valor de 
\begin_inset Formula $n$
\end_inset

 pasado algún umbral, entonces 
\begin_inset Formula $T=\Theta(f)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Remark
Para el teorema maestro, el término 
\begin_inset Formula $n/b$
\end_inset

 también se puede interpretar como 
\begin_inset Formula $\lceil n/b\rceil$
\end_inset

 o 
\begin_inset Formula $\lfloor n/b\rfloor$
\end_inset

.
\end_layout

\begin_layout Standard
La principal desventaja del teorema maestro es que no puede aplicarse a
 cualquier tipo de recurrencia.
 La demostración del teorema maestro se puede encontrar en el libro de Cormen
 et al.
\end_layout

\begin_layout Section
El método del árbol recursivo
\end_layout

\begin_layout Standard
El método del árbol recursivo es un método gráfico e informal que consiste
 de construir un árbol donde cada sub-árbol representa el tiempo requerido
 para resolver un subproblema en la recurrencia.
 Al sumar el tiempo total de cada nivel del árbol se obtiene la forma cerrada.
 
\end_layout

\begin_layout Standard
Antes de estudiar el método en sí, es importante recordar las sig.
 propiedades de los árboles 
\begin_inset Formula $k$
\end_inset

-arios.
\end_layout

\begin_layout Proposition
Sea 
\begin_inset Formula $k\in\mathbb{N}_{0}$
\end_inset

 y 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

.
 La altura de un árbol 
\begin_inset Formula $k$
\end_inset

-ario de 
\begin_inset Formula $n$
\end_inset

 nodos se calcula como 
\begin_inset Formula $\lfloor\log_{k}n\rfloor+1$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proposition
Sea 
\begin_inset Formula $i\in\mathbb{N}_{0}$
\end_inset

.
 Suponiendo que la raíz de un árbol 
\begin_inset Formula $k$
\end_inset

-ario completo se encuentra en el nivel 0, la cantidad de nodos en el nivel
 
\begin_inset Formula $i$
\end_inset

, se calcula como 
\begin_inset Formula $k^{i}$
\end_inset

.
\end_layout

\begin_layout Standard
El método del árbol recursivo consiste de los sig.
 pasos:
\end_layout

\begin_layout Enumerate
Desglozar la recurrencia en un árbol de tal forma que la raíz representa
 el tiempo requerido para combinar y/o dividir el problema original.
 Cada nodo interno representa el tiempo requerido para combinar y/o dividir
 un subproblema y cada hoja representa el tiempo requerido por el caso base.
 
\end_layout

\begin_layout Enumerate
Calcular la altura del árbol.
\end_layout

\begin_layout Enumerate
Calcular la cantidad de hojas.
\end_layout

\begin_layout Enumerate
Para cada nivel, sumar el tiempo de ejecución de sus nodos.
 
\end_layout

\begin_layout Enumerate
Sumar el tiempo de ejecución de todos los niveles para obtener la forma
 cerrada.
\end_layout

\begin_layout Section
El método de sustitución
\end_layout

\begin_layout Standard
El método de sustitución es un método formal que consiste en resolver una
 recurrencia por inducción matemática.
 Específicamente, este método consiste de los sig.
 pasos:
\end_layout

\begin_layout Enumerate
Proponer una cota asintótica que funja como una solución tentativa para
 la recurrencia.
\end_layout

\begin_layout Enumerate
Utilizar inducción matemática para demostrar que la cota propuesta es correcta
 y para encontrar las constantes de dicha cota.
\end_layout

\begin_layout Standard
Este método se puede utilizar para calcular tanto una cota superior como
 una inferior.
 A continuación se presentan algunas consideraciones y consejos que se deben
 tener en cuenta al trabajar con este método.
 
\end_layout

\begin_layout Itemize
Para proponer una buena solución tentativa:
\end_layout

\begin_deeper
\begin_layout Itemize
Se puede utilizar el método del árbol recursivo para obtener una solución
 tentativa y después utilizar el método de sustitución para demostrar que
 dicha solución es correcta o para ajustar la cota.
\end_layout

\begin_layout Itemize
Si la recurrencia tiene una forma similar a alguna cuya solución ya se conoce,
 se puede proponer esa solución como una solución tentativa.
\end_layout

\begin_layout Itemize
Se pueden proponer dos cotas holgadas, una inferior y una superior, y ajustarlas
 gradualmente hasta que converjan en la solución correcta.
 
\end_layout

\end_deeper
\begin_layout Itemize
Diferencias con la inducción matemática:
\end_layout

\begin_deeper
\begin_layout Itemize
El caso base se realiza hasta el último.
\end_layout

\begin_layout Itemize
La hipótesis inductiva consiste de suponer que la cota se cumple para 
\begin_inset Formula $T(n_{i})$
\end_inset

.
\end_layout

\begin_layout Itemize
El paso inductivo consiste en sustituir 
\begin_inset Formula $T(n_{i})$
\end_inset

, en la recurrencia original, con la forma exacta de la cota de la hipótesis
 inductiva.
 Este paso da origen al nombre del método.
\end_layout

\end_deeper
\begin_layout Itemize
Se debe demostrar algebraicamente que la cota propuesta se cumple de forma
 exacta.
 Es incorrecto aplicar la notación asintótica en el paso inductivo para
 deshacerse de constantes o términos problemáticos.
\end_layout

\begin_layout Itemize
Cuando la cota popuesta es lo más ajustada posible, pero aún así la inducción
 no converge, en lugar de proponer una cota más holgada, se puede proponer
 una nueva hipótesis inductiva cuya única diferencia con la anterior es
 que se le restan los términos de menor grado.
\end_layout

\begin_layout Section
Cambio de variable
\end_layout

\begin_layout Standard
En ocasiones, se puede aplicar álgebra para transformar una recurrencia
 en alguna otra cuya solución ya se conozca, eliminando por completo la
 necesidad de recurrir a cualquiera de los métodos anteriores.
\end_layout

\begin_layout Section*
Notas bibliográficas
\end_layout

\begin_layout Standard
En las págs.
 112 y 113 del libro de Cormen et al.
 se proporcionan referencias a otros métodos que existen para resolver diferente
s tipos de recurrencias.
 Uno de ellos es el método de Akra-Bazzi, el cual es una generalización
 del teorema maestro que admite variables contínuas y permite resolver recurrenc
ias donde los subproblemas varían substancialmente de tamaño.
 El método de Drmota y Szpankowski (2013) es una extensión del método de
 Akra-Bazzi para trabajar con variables discretas.
 
\end_layout

\begin_layout Itemize
Cormen T.H., Leiserson C.E., Rivest R.L.
 & Stein C., 
\begin_inset Quotes fls
\end_inset

Introduction to Algorithms
\begin_inset Quotes frs
\end_inset

, 3ra ed.
 (2009), MIT Press.
 Págs.
 83-106 y 112-113.
\end_layout

\begin_layout Itemize
Drmota M.
 & Szpankowski W., 
\begin_inset Quotes fls
\end_inset

A Master Theorem for Discrete Divide and Conquer Recurrences
\begin_inset Quotes frs
\end_inset

, Journal of the ACM (2013), Art.
 No.
 16.
\end_layout

\end_body
\end_document
