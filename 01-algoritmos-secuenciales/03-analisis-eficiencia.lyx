#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\usepackage{indentfirst}

\usepackage{titlesec}
\titleformat{\chapter}[display]{\bfseries\centering\larger}{\normalsize{\chaptertitlename\ \thechapter}}{0.5ex}{}[]
\titlespacing*{\chapter}{0pt}{-50pt}{20pt}
\titleformat{\section}[hang]{\bfseries\normalsize}{\thesection\ }{0pt}{}[]
\titleformat{\subsection}[runin]{\bfseries\normalsize}{\thesubsection\ }{0pt}{}[]
\titleformat{\paragraph}[runin]{\itshape\normalsize}{\theparagraph\ }{0pt}{}[]

\newtheoremstyle{myplain}{\topsep}{\topsep}{\itshape}{}{\scshape}{.}{.5em}{}
\newtheoremstyle{mydef}{\topsep}{\topsep}{\normalfont}{}{\scshape}{.}{.5em}{}
\theoremstyle{myplain}
\newtheorem{mythm}{Teorema}[]
\newtheorem{mylem}{Lema}[]
\newtheorem{myprop}{Proposición}[]
\theoremstyle{mydef}
\newtheorem{mydef}{Definición}[]
\newtheorem{myrmk}{Observación}[]
\newtheorem{myex}{Ejemplo}[]

\let\thm\mythm
\let\endthm\endmythm
\let\lem\mylem
\let\endlem\endmylem
\let\prop\myprop
\let\endprop\endmyprop
\let\defn\mydef
\let\enddefn\endmydef
\let\example\myex
\let\endexample\endmyex
\let\rem\myrmk
\let\endrem\endmyrmk

\usepackage{xpatch}
\newcommand{\proofnamefont}{\scshape}
\xpatchcmd{\proof}{\itshape}{\normalfont\proofnamefont}{}{}
\end_preamble
\use_default_options true
\begin_modules
algorithm2e
theorems-ams-bytype
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Format 66
PackageOptions algorithm2e "vlined,linesnumbered,ruled"
\end_local_layout
\language spanish-mexico
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tb
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.57in
\topmargin 1.2in
\rightmargin 1.2in
\bottommargin 1.2in
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\bullet 0 2 5 -1
\bullet 1 5 35 -1
\bullet 2 2 11 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Análisis de la Eficiencia de un Algoritmo
\end_layout

\begin_layout Standard
Después de demostrar que un algoritmo es correcto, el sig.
 paso es caracterizar su tiempo de ejecución.
 El procedimiento que se sigue para realizar esta tarea se demonima 
\emph on
análisis de la eficiencia
\emph default
 
\emph on
de un algoritmo 
\emph default
(o, simplemente, 
\emph on
análisis de eficiencia
\emph default
).
 En este contexto, cuando se habla del 
\begin_inset Quotes fls
\end_inset

tiempo de ejecución
\begin_inset Quotes frs
\end_inset

 de alguna operación o algoritmo, en realidad se está hablando de la cantidad
 total de instrucciones que se ejecutan.
 
\end_layout

\begin_layout Section
El modelo de cómputo RAM
\end_layout

\begin_layout Standard
Un 
\emph on
modelo de cómputo
\emph default
 (o, simplemente, 
\emph on
modelo
\emph default
) es una representación simplificada de alguna tecnología de cómputo particular
 que funge como una 
\begin_inset Quotes fls
\end_inset

máquina hipotética
\begin_inset Quotes frs
\end_inset

 donde se puede simular la ejecución de un algoritmo para llevar a cabo
 su análisis.
 El modelo debe ser lo suficientemente simple para que facilite el análisis
 y, a la vez, lo suficientemente cercano a la tecnología que representa
 para que refleje lo más fielmente posible el comportamiento que tendría
 el algoritmo de ser implementado en dicha tecnología.
 
\end_layout

\begin_layout Standard
Existen varios modelos de cómputo, pero el más comúnmente utilizado para
 analizar algoritmos secuenciales es el 
\emph on
modelo RAM 
\emph default
(random access machine).
 El modelo RAM simula la arquitectura de von Neumann y, como tal, consiste
 de una unidad de procesamiento central conectada a una unidad de memoria
 de acceso aleatorio.
 El 
\emph on
ciclo de máquina
\emph default
 del modelo RAM consiste de tres pasos: 
\end_layout

\begin_layout Enumerate
Se lee algún dato de la memoria.
 
\end_layout

\begin_layout Enumerate
Se ejecuta alguna instrucción sobre ése dato.
\end_layout

\begin_layout Enumerate
Se escribe el resultado en la memoria.
 
\end_layout

\begin_layout Standard
Cada ciclo de máquina se ejecuta en tiempo constante (i.e.
 independiente del valor o tamaño del dato de entrada).
 
\end_layout

\begin_layout Standard
En términos prácticos, al simular la ejecución de un algoritmo en el modelo
 RAM, se deben seguir las sig.
 suposiciones:
\end_layout

\begin_layout Itemize
Las instrucciones se pueden ejecutar únicamente de forma secuencial; no
 se permite ejecutar instrucciones concurrentes.
 
\end_layout

\begin_layout Itemize
Todas las operaciones lógicas, aritméticas y de comparación se ejecutan
 en tiempo constante, con la excepción del exponente, el factorial, la raíz,
 el logaritmo, i.a.
\end_layout

\begin_layout Itemize
Se cuenta con una cantidad infinita de memoria.
 
\end_layout

\begin_layout Itemize
Todas las operaciones de memoria (ya sea por puntero, índice o variable)
 se ejecutan en tiempo constante; no se hace distinción entre si un dato
 se encuentra en memoria caché, en la memoria RAM, en el disco duro, etc.
 
\end_layout

\begin_layout Itemize
Invocar una rutina toma tiempo constante, pero el tiempo requerido para
 ejecutar dicha rutina depende del tamaño de su entrada.
\end_layout

\begin_layout Section
Casos a considerar
\end_layout

\begin_layout Standard
Las clases de entrada de un algoritmo pueden categorizarse en tres casos
 diferentes, dependiendo de cómo influyen en el tiempo de ejecución de dicho
 algoritmo:
\end_layout

\begin_layout Itemize

\emph on
Mejor caso
\emph default
: son todos los casos específicos que provocan que el algoritmo ejecute
 la menor cantidad de instrucciones posible.
 
\end_layout

\begin_layout Itemize

\emph on
Peor caso
\emph default
: son todos los casos específicos que provocan que el algoritmo ejecute
 la mayor cantidad de instrucciones posible.
 
\end_layout

\begin_layout Itemize

\emph on
Caso promedio
\emph default
: representa la cantidad promedio de instrucciones que el algoritmo realiza
 para todos los posibles casos específicos.
 
\end_layout

\begin_layout Standard
En la práctica, se suele estudiar únicamente el peor caso.
 En ocasiones también se estudia el caso promedio; e.g.
 cuando el caso promedio ocurre con mayor frecuencia que los demás o cuando
 se está analizando un algoritmo aleatorio.
 
\end_layout

\begin_layout Section
Procedimiento general del análisis
\end_layout

\begin_layout Standard
El análisis de la eficiencia de un algoritmo consiste de multiplicar el
 tiempo de ejecución de cada instrucción (suponiendo que el algoritmo se
 ejecuta en el modelo RAM) por el número de veces que se ejecutan (dada
 una entrada genérica de tamaño arbitrariamente grande y perteneciente a
 alguna de las clases de entrada identificadas).
 Al final, se suman estos productos.
 
\end_layout

\begin_layout Standard
Como resultado final del análisis, se obtiene una función 
\begin_inset Formula $T:\mathbb{N}\to\mathbb{N}$
\end_inset

 que determina el número total de instrucciones que el algoritmo ejecuta
 en proporción al tamaño 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

 de la entrada, donde el significado de 
\begin_inset Quotes fls
\end_inset

tamaño
\begin_inset Quotes frs
\end_inset

 depende del contexto del problema que se está tratando.
 Dicha función se expresa por medio de su orden de crecimiento.
 Cabe mencionar que siempre se puede suponer, sin pérdida de generalidad,
 que 
\begin_inset Formula $T$
\end_inset

 es una función asintóticamente positiva.
 
\end_layout

\begin_layout Section*
Notas bibliográficas
\end_layout

\begin_layout Itemize
Cormen T.H., Leiserson C.E., Rivest R.L.
 & Stein C., 
\begin_inset Quotes fls
\end_inset

Introduction to Algorithms
\begin_inset Quotes frs
\end_inset

, 3ra ed.
 (2009), MIT Press.
 Págs.
 23-29.
\end_layout

\begin_layout Itemize
Skiena S.S., 
\begin_inset Quotes fls
\end_inset

The Algorithm Design Manual
\begin_inset Quotes frs
\end_inset

, 2da ed.
 (2012), Springer.
 Págs.
 31-34.
\end_layout

\end_body
\end_document
