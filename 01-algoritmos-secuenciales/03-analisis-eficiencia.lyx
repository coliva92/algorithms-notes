#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\usepackage{titlesec}
\titleformat{\chapter}[display]{\bfseries\centering\large}{\normalsize{\chaptertitlename\ \thechapter}}{0.5ex}{}[]
\titlespacing*{\chapter}{0pt}{-50pt}{20pt}
\titleformat{\section}[hang]{\bfseries\large}{\thesection\ }{0pt}{}[]
\titleformat{\subsection}[hang]{\bfseries\normalsize}{\thesubsection\ }{0pt}{}[]
\titleformat{\paragraph}[runin]{\itshape\normalsize}{\theparagraph\ }{0pt}{}[]

\usepackage{enumitem}
\setlist{nolistsep}

\SetKwInOut{In}{Entrada}
\SetKwInOut{Out}{Salida}
\SetKw{Throw}{throw}
\SetKw{Error}{error}
\SetKw{And}{and}
\SetKw{Or}{or}
\SetKw{Not}{not}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Nil}{nil}
\SetCommentSty{textit}
\SetKwComment{Comment}{$\triangleright$ }{}
\SetFuncSty{textsc}
\DontPrintSemicolon
\end_preamble
\use_default_options true
\begin_modules
algorithm2e
theorems-ams-chap-bytype
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Format 66
PackageOptions algorithm2e "algochapter,vlined,linesnumbered,ruled"
\end_local_layout
\language spanish-mexico
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tb
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.57in
\topmargin 1.2in
\rightmargin 1.2in
\bottommargin 1.2in
\secnumdepth 2
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\bullet 0 2 5 -1
\bullet 1 5 35 -1
\bullet 2 2 11 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Análisis de la Eficiencia de un Algoritmo
\end_layout

\begin_layout Standard
Después de demostrar que un algoritmo es correcto, el sig.
 paso es caracterizar su tiempo de ejecución.
 El procedimiento que se sigue para realizar esta tarea se demonima 
\emph on
análisis de la eficiencia
\emph default
 
\emph on
de un algoritmo
\emph default
.
 En este contexto, el tiempo de ejecución de un algoritmo se mide como la
 cantidad total de instrucciones que se ejecutan.
 
\end_layout

\begin_layout Section
El modelo de cómputo RAM
\end_layout

\begin_layout Standard
Un 
\emph on
modelo de cómputo
\emph default
 (o, simplemente, 
\emph on
modelo
\emph default
) es una representación simplificada de alguna tecnología de cómputo particular
 que funge como una 
\begin_inset Quotes fls
\end_inset

máquina hipotética
\begin_inset Quotes frs
\end_inset

 donde se puede simular la ejecución de un algoritmo para llevar a cabo
 su análisis.
 El modelo debe ser lo suficientemente simple para facilitar el análisis
 y lo suficientemente cercano a la tecnología que representa para que refleje
 lo más fielmente posible el comportamiento que tendría el algoritmo de
 ser implementado en dicha tecnología.
 
\end_layout

\begin_layout Standard
Existen varios modelos de cómputo, pero el más utilizado para analizar algoritmo
s secuenciales es el 
\emph on
modelo RAM 
\emph default
(random access machine).
 
\end_layout

\begin_layout Standard
El modelo RAM simula la arquitectura de von Neumann, la cual consiste de
 una unidad de procesamiento central conectada por algún medio a una unidad
 de memoria de acceso aleatorio.
 Esta arquitectura se caracteriza en que las instrucciones de un programa
 particular y los datos del mismo se almacenan en la misma unidad memoria
 y se transmiten al procesador utilizando el mismo medio.
 Como consecuencia, no se puede ejecutar una instrucción al mismo tiempo
 que se lee o se escribe un dato en memoria.
 Estas mismas características también aplican para el modelo RAM.
\end_layout

\begin_layout Standard
Así, el 
\emph on
ciclo de máquina
\emph default
 del modelo RAM consiste de tres pasos: 
\end_layout

\begin_layout Enumerate
Se lee algún dato de la memoria.
 
\end_layout

\begin_layout Enumerate
Se ejecuta alguna instrucción sobre ése dato.
\end_layout

\begin_layout Enumerate
Se escribe el resultado en la memoria.
 
\end_layout

\begin_layout Standard
Cada ciclo de máquina se ejecuta en tiempo constante (i.e.
 independiente del valor o tamaño del dato de entrada).
 
\end_layout

\begin_layout Standard
En términos prácticos, al simular la ejecución de un algoritmo en el modelo
 RAM, se deben seguir las sig.
 suposiciones:
\end_layout

\begin_layout Itemize
Las instrucciones se pueden ejecutar únicamente de forma secuencial.
 
\end_layout

\begin_layout Itemize
Todas las operaciones lógicas, aritméticas y de comparación se ejecutan
 en tiempo constante, con la excepción del exponente, el factorial, la raíz
 y el logaritmo.
\end_layout

\begin_layout Itemize
Se cuenta con una cantidad infinita de memoria.
 
\end_layout

\begin_layout Itemize
Todas las operaciones de memoria (ya sea por puntero, índice o variable)
 se ejecutan en tiempo constante; no se hace distinción entre si un dato
 se encuentra en memoria caché, en la memoria RAM, en el disco duro, etc.
 
\end_layout

\begin_layout Itemize
Invocar una sub-rutina toma tiempo constante, pero el tiempo requerido para
 ejecutarla depende del tamaño de su entrada.
\end_layout

\begin_layout Section
Casos a considerar
\end_layout

\begin_layout Standard
Las clases de entrada de un algoritmo pueden categorizarse en tres casos
 diferentes, dependiendo de cómo influyen en el tiempo de ejecución de dicho
 algoritmo:
\end_layout

\begin_layout Itemize

\emph on
Mejor caso
\emph default
: son todos los casos específicos que provocan que el algoritmo ejecute
 la menor cantidad de instrucciones posible.
 
\end_layout

\begin_layout Itemize

\emph on
Peor caso
\emph default
: son todos los casos específicos que provocan que el algoritmo ejecute
 la mayor cantidad de instrucciones posible.
 
\end_layout

\begin_layout Itemize

\emph on
Caso promedio
\emph default
: representa la cantidad promedio de instrucciones que el algoritmo realiza
 para todos los posibles casos específicos.
 
\end_layout

\begin_layout Standard
En la práctica, se suele estudiar únicamente el peor caso.
 En ocasiones también se estudia el caso promedio; e.g.
 cuando el caso promedio ocurre con mayor frecuencia que los demás o cuando
 se está analizando un algoritmo aleatorio.
 
\end_layout

\begin_layout Section
Procedimiento general del análisis
\end_layout

\begin_layout Standard
El análisis de la eficiencia de un algoritmo consiste de multiplicar el
 tiempo de ejecución de cada instrucción (suponiendo que se ejecuta en el
 modelo RAM) por el número de veces que se ejecuta (dada una entrada genérica
 de tamaño arbitrariamente grande y perteneciente a alguna de las clases
 de entrada identificadas).
 Al final, se suman estos productos.
 
\end_layout

\begin_layout Standard
Como resultado final del análisis, se obtiene una función 
\begin_inset Formula $T:\mathbb{N}\to\mathbb{N}$
\end_inset

 que determina el número total de instrucciones que el algoritmo ejecuta
 en proporción al tamaño de la entrada 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

.
 Esta función se expresa por medio de su orden de crecimiento y se puede
 suponer sin pérdida de generalidad que es asintóticamente positiva.
 
\end_layout

\begin_layout Standard
Cabe mencionar que el significado de 
\begin_inset Quotes fls
\end_inset

tamaño de la entrada
\begin_inset Quotes frs
\end_inset

 depende del contexto del problema que se está tratando.
 Por ejemplo, 
\begin_inset Formula $n$
\end_inset

 podría referirse a la longitud de un arreglo, al número de vértices en
 un grafo, a la longitud de una cadena binaria, etc.
\end_layout

\begin_layout Section*
Notas bibliográficas
\end_layout

\begin_layout Itemize
Cormen T.H., Leiserson C.E., Rivest R.L.
 & Stein C., 
\begin_inset Quotes fls
\end_inset

Introduction to Algorithms
\begin_inset Quotes frs
\end_inset

, 3ra ed.
 (2009), MIT Press.
 Págs.
 23-29.
\end_layout

\begin_layout Itemize
Skiena S.S., 
\begin_inset Quotes fls
\end_inset

The Algorithm Design Manual
\begin_inset Quotes frs
\end_inset

, 2da ed.
 (2012), Springer.
 Págs.
 31-34.
\end_layout

\begin_layout Itemize
Goodrich M.T.
 & Tamassia R., 
\begin_inset Quotes fls
\end_inset

Algorithm Design: Foundations, Analysis and Internet Examples
\begin_inset Quotes frs
\end_inset

, 2da ed.
 (2006), Wikey & Sons Inc.
 Págs.
 5-6, 9-11.
\end_layout

\end_body
\end_document
